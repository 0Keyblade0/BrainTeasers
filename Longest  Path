(defun longest-path (start end net)
  (or (reverse (dfs (list start) start end net nil))
      (and (eql start end) (list start))))

(defun longer-path (path1 path2)
  (if (> (length path1) (length path2)) path1 path2))

(defun path-thru-node (path node end net)
  (cond ((eql node end) (cons node path))
        ((member node path) nil)
        (t (dfs (cons node path) node end net nil))))

(defun dfs (path node end net best-so-far)
  (reduce (lambda (current-best neighbor)
            (longer-path current-best (path-thru-node path neighbor end net)))
          (cdr (assoc node net))
          :initial-value best-so-far))
